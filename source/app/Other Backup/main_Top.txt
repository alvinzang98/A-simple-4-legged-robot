#include "NUC131.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>


//=========================================================
// Top - Shooter Platform
//=========================================================
// Pin Mapping
//=========================================================
// Shooter
// Motor_01_PWM			PA13/PWM0_CH1
// Motor_01_Direction	PA14/PWM0_CH2
// Motor_01_Enable		PA15/PWM0_CH3
//=========================================================
// Platform ¨C L298
// Motor_02_IN1			PA12/PWM0_CH0
// Motor_02_IN2 		PA1 /PWM0_CH5
// Motor_02_Enable		PA4
// Motor_02_Limit_Up	PC7
// Motor_02_Limit_Down	PC6
//=========================================================
// Feeder ¨C L298
// Motor_03_IN3			PA2 /PWM1_CH0
// Motor_03_IN4			PA3 /PWM1_CH1
// Motor_03_Enable		PA5
// Motor_03_Limit_In	PB8
// Motor_03_Litmit_Out	PF8
//=========================================================
// BT_Control_UART_TX	PB0/UART0_RXD
// BT_Control_UART_RX	PB1/UART0_TXD
//=========================================================
// BT_Debug_UART_TX		PB4/UART1_RXD
// BT_Debug_UART_RX		PB5/UART1_TXD
//=========================================================
// CAN_RXD				PD6/CAN0_RXD
// CAN_TXD				PD7/CAN0_TXD
// CAN_Standby			PF05 // 0 = Normal Mode, 1 = Standby Mode
//=========================================================
// LED_Operation_Down	PB0
// LED Operation_Up		PB1
//=========================================================




//=========================================================
// Robot Action Command
//=========================================================
int 			g_Robot_Action_CMD_01 = 0;
unsigned int 	g_User_Action_CMD_00;
//=========================================================



//=========================================================
// UART
//=========================================================
uint8_t     	g_UART_01_RX_Result_Buffer[100];
uint8_t     	g_UART_01_RX_Result_Buffer_Count 	= 0;
uint8_t     	g_UART_01_RX_Result_Status 			= 0;
unsigned int  	g_UART_01_RX_Result_Byte 			= 0;
//=========================================================



//=========================================================
// Motor
//=========================================================

//=========================================================
// Shooter
unsigned int  	g_Motor_01_Control_PWM_Frequency  	= 0; // Shooter
unsigned int  	g_Motor_01_Control_PWM_DutyCycle   	= 0; // Shooter
unsigned int  	g_Motor_01_Control_Direction_Value 	= 0; // Shooter
unsigned int	g_Motor_01_Position_Status_Shooter	= 0; // Shooter
//=========================================================
// Platform
unsigned int  	g_Motor_02_Control_PWM_Frequency  	= 0; // Platform
unsigned int  	g_Motor_02_Control_PWM_DutyCycle   	= 0; // Platform
unsigned int  	g_Motor_02_Control_Direction_Value 	= 0; // Platform
unsigned int	g_Motor_02_Position_Status_Platform	= 0; // Platform
//=========================================================
// Feeder
unsigned int  	g_Motor_03_Control_PWM_Frequency  	= 0; // Feeder
unsigned int  	g_Motor_03_Control_PWM_DutyCycle   	= 0; // Feeder
unsigned int  	g_Motor_03_Control_Direction_Value 	= 0; // Feeder
unsigned int	g_Motor_03_Position_Status_Feeder	= 0; // Feeder
//=========================================================




//=========================================================
// Function
//=========================================================
void f_SYS_Init				(void);
void f_SYS_Exit				(void);
void f_Startup_Init			(void);
//=========================================================
void f_Motor_Control_Delay	(void);
void f_Motor_Control		(unsigned int t_Motor, unsigned int t_Direction, unsigned int t_PWM_DutyCycle, unsigned int t_PWM_Frequency);
//=========================================================
void f_Robot_Top_Shooter	(unsigned int t_Action, unsigned int t_Speed);
void f_Robot_Top_Platform	(unsigned int t_Action, unsigned int t_Speed);
void f_Robot_Top_Feeder		(unsigned int t_Action, unsigned int t_Speed);
//=========================================================



void UART1_IRQHandler(void)
{
    uint32_t     	u32IntSts						= UART1->ISR;
    uint8_t      	t_UART_01_RX_Result_Buffer[1] 	= {0};
    unsigned int 	t_UART_01_RX_Result_Byte      	= 0;

    if(u32IntSts & UART_IS_RX_READY(UART1))
    {
       	UART_Read(UART1, t_UART_01_RX_Result_Buffer, sizeof(t_UART_01_RX_Result_Buffer));
       	t_UART_01_RX_Result_Byte = (unsigned int)t_UART_01_RX_Result_Buffer[0];
       	g_UART_01_RX_Result_Byte = t_UART_01_RX_Result_Byte;
       	g_User_Action_CMD_00 = g_UART_01_RX_Result_Byte;
       	UART_Write(UART1, t_UART_01_RX_Result_Buffer, sizeof(t_UART_01_RX_Result_Buffer));
    }
}

void f_Motor_Control_Delay(void)
{
	int n = 0;
	int DoSomething = 0;
	for(n=0;n<200000;n++)
	{
		DoSomething = 0;
	}
}

void f_Motor_Control(unsigned int t_Motor, unsigned int t_Direction, unsigned int t_PWM_DutyCycle, unsigned int t_PWM_Frequency)
{
	//===================================================
	// t_Motor 			: 1 = Shooter, 2 = Platform, 3 = Feeder
	//===================================================
	// t_Motor 			: 1 = Shooter
	// t_Direction 		: 1 = Forward, 2 = Backward
	// t_PWM_DutyCycle 	: 0 - 100
	//===================================================
	// t_Motor 			: 2 = Platform
	// t_Direction 		: 1 = Up, 2 = Down
	// t_PWM_DutyCycle 	: 0 - 100
	//===================================================
	// t_Motor 			: 3 = Feeder
	// t_Direction 		: 1 = In, 2 = Out
	// t_PWM_DutyCycle 	: 0 - 100
	//===================================================

	if (t_Motor == 1) // Shooter
	{
		if (t_Direction == 1)
		{
			PA14 = 1;
		}
		else if (t_Direction == 2)
		{
			PA14 = 0;
		}

		else if (t_Direction == 0)
		{
			t_PWM_DutyCycle = 0;
		}

		if(((0<t_PWM_DutyCycle)&&(t_PWM_DutyCycle<=100))&&((100<=t_PWM_Frequency)&&(t_PWM_Frequency<=5000)))
		{
			PA15 = 1;
			PWM_ConfigOutputChannel(PWM0, 1, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM0, PWM_CH_1_MASK);
			PWM_Start(PWM0, PWM_CH_1_MASK);
		}
		else if((t_PWM_DutyCycle==0)&&((100<=t_PWM_Frequency)&&(t_PWM_Frequency<=5000)))
		{
			PA15 = 0;
			PWM_ConfigOutputChannel(PWM0, 1, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM0, PWM_CH_1_MASK);
			PWM_Start(PWM0, PWM_CH_1_MASK);
		}
		else
		{
			t_PWM_Frequency = 100;
			t_PWM_DutyCycle = 0;
			PA15 = 0;
			PWM_ConfigOutputChannel(PWM0, 1, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM0, PWM_CH_1_MASK);
			PWM_Start(PWM0, PWM_CH_1_MASK);
		}
	}
	else if (t_Motor == 2) // Platform
	{
		if (t_Direction == 1)
		{
			if(0<t_PWM_DutyCycle)
			{
				t_PWM_DutyCycle = 100-t_PWM_DutyCycle;
			}

			if(PA1==1)
			{
				PA4 = 0;
			}
			f_Motor_Control_Delay();
			PA1 = 0;
			f_Motor_Control_Delay();
		}
		else if (t_Direction == 2)
		{
			if(PA1==0)
			{
				PA4 = 0;
			}
			f_Motor_Control_Delay();
			PA1 = 1;
			f_Motor_Control_Delay();
		}
		else if (t_Direction == 0)
		{
			f_Motor_Control_Delay();
			PA4 = 0;
			t_PWM_DutyCycle = 0;
			f_Motor_Control_Delay();
		}

		if(((0<t_PWM_DutyCycle)&&(t_PWM_DutyCycle<=100))&&((100<=t_PWM_Frequency)&&(t_PWM_Frequency<=5000)))
		{
			PA4 = 1;
			t_PWM_DutyCycle = 100 - t_PWM_DutyCycle;
			PWM_ConfigOutputChannel(PWM0, 0, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM0, PWM_CH_0_MASK);
			PWM_Start(PWM0, PWM_CH_0_MASK);
		}
		else if((t_PWM_DutyCycle==0)&&((100<=t_PWM_Frequency)&&(t_PWM_Frequency<=5000)))
		{
			PA4 = 0;
			PWM_ConfigOutputChannel(PWM0, 0, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM0, PWM_CH_0_MASK);
			PWM_Start(PWM0, PWM_CH_0_MASK);
		}
		else
		{
			t_PWM_Frequency = 100;
			t_PWM_DutyCycle = 0;
			PA4 = 0;
			PWM_ConfigOutputChannel(PWM0, 0, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM0, PWM_CH_0_MASK);
			PWM_Start(PWM0, PWM_CH_0_MASK);
		}
	}
	else if (t_Motor == 3) // Feeder
	{
		if (t_Direction == 1)
		{
			PA3 = 1;
		}
		else if (t_Direction == 2)
		{
			PA3 = 0;
			if(0<t_PWM_DutyCycle)
			{
				t_PWM_DutyCycle = 100-t_PWM_DutyCycle;
			}
		}
		else if (t_Direction == 0)
		{
			t_PWM_DutyCycle = 0;
		}

		if(((0<t_PWM_DutyCycle)&&(t_PWM_DutyCycle<=100))&&((100<=t_PWM_Frequency)&&(t_PWM_Frequency<=5000)))
		{
			PA5 = 1;
			t_PWM_DutyCycle = 100 - t_PWM_DutyCycle;
			PWM_ConfigOutputChannel(PWM1, 0, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM1, PWM_CH_0_MASK);
			PWM_Start(PWM1, PWM_CH_0_MASK);
		}
		else if((t_PWM_DutyCycle==0)&&((100<=t_PWM_Frequency)&&(t_PWM_Frequency<=5000)))
		{
			PA5 = 0;
			PWM_ConfigOutputChannel(PWM1, 0, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM1, PWM_CH_0_MASK);
			PWM_Start(PWM1, PWM_CH_0_MASK);
		}
		else
		{
			t_PWM_Frequency = 100;
			t_PWM_DutyCycle = 0;
			PA5 = 0;
			PWM_ConfigOutputChannel(PWM1, 0, t_PWM_Frequency, t_PWM_DutyCycle);
			PWM_EnableOutput(PWM1, PWM_CH_0_MASK);
			PWM_Start(PWM1, PWM_CH_0_MASK);
		}
	}
}

void f_Robot_Top_Shooter(unsigned int t_Action, unsigned int t_Speed)
{
	//===================================================
	// t_Motor 			: 1 = Shooter
	// t_Direction 		: 0 = Stop, 1 = Forward, 2 = Backward
	// t_PWM_DutyCycle 	: 0 - 100
	//===================================================
	if(t_Action==0) // Stop
	{
		g_Motor_01_Control_PWM_Frequency  	= 100;
		g_Motor_01_Control_PWM_DutyCycle   	= 0;
		g_Motor_01_Control_Direction_Value 	= 0;
		f_Motor_Control(1, g_Motor_01_Control_Direction_Value, g_Motor_01_Control_PWM_DutyCycle, g_Motor_01_Control_PWM_Frequency);
	}
	else if(t_Action==1) // Forward
	{
		g_Motor_01_Control_PWM_Frequency  	= 100;
		g_Motor_01_Control_PWM_DutyCycle   	= t_Speed;
		g_Motor_01_Control_Direction_Value 	= 1;
		f_Motor_Control(1, g_Motor_01_Control_Direction_Value, g_Motor_01_Control_PWM_DutyCycle, g_Motor_01_Control_PWM_Frequency);
	}
	else if(t_Action==2) // Backward
	{
		g_Motor_01_Control_PWM_Frequency  	= 100;
		g_Motor_01_Control_PWM_DutyCycle   	= t_Speed;
		g_Motor_01_Control_Direction_Value 	= 2;
		f_Motor_Control(1, g_Motor_01_Control_Direction_Value, g_Motor_01_Control_PWM_DutyCycle, g_Motor_01_Control_PWM_Frequency);
	}
}


void f_Robot_Top_Platform(unsigned int t_Action, unsigned int t_Speed)
{
	//===================================================
	// t_Motor 			: 2 = Platform
	// t_Direction 		: 0 = Stop, 1 = Up, 2 = Down
	// t_PWM_DutyCycle 	: 0 - 100
	//===================================================
	if(t_Action==0) // Stop
	{
		g_Motor_02_Control_PWM_Frequency  	= 100;
		g_Motor_02_Control_PWM_DutyCycle   	= 0;
		g_Motor_02_Control_Direction_Value 	= 0;
		f_Motor_Control(2, g_Motor_02_Control_Direction_Value, g_Motor_02_Control_PWM_DutyCycle, g_Motor_02_Control_PWM_Frequency);
	}
	else if(t_Action==1) // Up
	{
		g_Motor_02_Control_PWM_Frequency  	= 100;
		g_Motor_02_Control_PWM_DutyCycle   	= t_Speed;
		g_Motor_02_Control_Direction_Value 	= 1;
		f_Motor_Control(2, g_Motor_02_Control_Direction_Value, g_Motor_02_Control_PWM_DutyCycle, g_Motor_02_Control_PWM_Frequency);
	}
	else if(t_Action==2) // Down
	{
		g_Motor_02_Control_PWM_Frequency  	= 100;
		g_Motor_02_Control_PWM_DutyCycle   	= t_Speed;
		g_Motor_02_Control_Direction_Value 	= 2;
		f_Motor_Control(2, g_Motor_02_Control_Direction_Value, g_Motor_02_Control_PWM_DutyCycle, g_Motor_02_Control_PWM_Frequency);
	}
}

void f_Robot_Top_Feeder(unsigned int t_Action, unsigned int t_Speed)
{
	//===================================================
	// t_Motor 			: 3 = Feeder
	// t_Direction 		: 0 = Stop, 1 = In, 2 = Out
	// t_PWM_DutyCycle 	: 0 - 100
	//===================================================
	if(t_Action==0) // Stop
	{
		g_Motor_02_Control_PWM_Frequency  	= 100;
		g_Motor_02_Control_PWM_DutyCycle   	= 0;
		g_Motor_02_Control_Direction_Value 	= 0;
		f_Motor_Control(2, g_Motor_02_Control_Direction_Value, g_Motor_02_Control_PWM_DutyCycle, g_Motor_02_Control_PWM_Frequency);
	}
	else if(t_Action==1) // In
	{
		g_Motor_02_Control_PWM_Frequency  	= 100;
		g_Motor_02_Control_PWM_DutyCycle   	= t_Speed;
		g_Motor_02_Control_Direction_Value 	= 1;
		f_Motor_Control(2, g_Motor_02_Control_Direction_Value, g_Motor_02_Control_PWM_DutyCycle, g_Motor_02_Control_PWM_Frequency);
	}
	else if(t_Action==2) // Out
	{
		g_Motor_02_Control_PWM_Frequency  	= 100;
		g_Motor_02_Control_PWM_DutyCycle   	= t_Speed;
		g_Motor_02_Control_Direction_Value 	= 2;
		f_Motor_Control(2, g_Motor_02_Control_Direction_Value, g_Motor_02_Control_PWM_DutyCycle, g_Motor_02_Control_PWM_Frequency);
	}
}

/*
void CAN0_IRQHandler(void)
{
	STR_CANMSG_T Temp_DataList_CAN_RX_01;
    uint32_t u8IIDRstatus = CAN0->IIDR;

    if(u8IIDRstatus == 0x00008000)
    {
        if(CAN0->STATUS & CAN_STATUS_RXOK_Msk)
        {
        	if (CAN_Receive(CAN0, 2, &Temp_DataList_CAN_RX_01) == 0x01)
        	{
        		if(Temp_DataList_CAN_RX_01.Id == m_Device_ID_Master)
        		{
        			m_DataList_CAN_RX = 1;
        			m_DataList_CAN_RX_01[0] = Temp_DataList_CAN_RX_01.Data[0];
        			m_DataList_CAN_RX_01[1] = Temp_DataList_CAN_RX_01.Data[1];
        			m_DataList_CAN_RX_01[2] = Temp_DataList_CAN_RX_01.Data[2];
        			m_DataList_CAN_RX_01[3] = Temp_DataList_CAN_RX_01.Data[3];
        			m_DataList_CAN_RX_01[4] = Temp_DataList_CAN_RX_01.Data[4];
        			m_DataList_CAN_RX_01[5] = Temp_DataList_CAN_RX_01.Data[5];
        			m_DataList_CAN_RX_01[6] = Temp_DataList_CAN_RX_01.Data[6];
        			m_DataList_CAN_RX_01[7] = Temp_DataList_CAN_RX_01.Data[7];
        		}
        	}
            CAN0->STATUS &= ~CAN_STATUS_RXOK_Msk;
        }
        CAN_CLR_INT_PENDING_BIT(CAN0, 2);

        if(CAN0->STATUS & CAN_STATUS_TXOK_Msk)
        {
            CAN0->STATUS &= ~CAN_STATUS_TXOK_Msk;
        }
    }
    else if((u8IIDRstatus >= 0x1) || (u8IIDRstatus <= 0x20))
    {
        CAN_CLR_INT_PENDING_BIT(CAN0, (u8IIDRstatus - 1));
    }
    else if(CAN0->WU_STATUS == 1)
    {
        CAN0->WU_STATUS = 0;
    }
}
*/

void f_SYS_Init(void)
{
	//================================================================================
	// Init Clock
	//================================================================================

    //==================================================
    // Init System Clock
    //==================================================
    CLK_EnableXtalRC(CLK_PWRCON_OSC22M_EN_Msk);
    CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);
    CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_HIRC, CLK_CLKDIV_HCLK(1));
    CLK_EnableXtalRC(CLK_PWRCON_XTL12M_EN_Msk);
    CLK_WaitClockReady(CLK_CLKSTATUS_XTL12M_STB_Msk);
    CLK_SetCoreClock(50000000);
    //==================================================
    // Init Module Clock - PWM0
    //==================================================
    CLK_SetModuleClock(PWM0_MODULE, CLK_CLKSEL3_PWM0_S_PLL, 0);
    CLK_EnableModuleClock(PWM0_MODULE);
    SYS_ResetModule(PWM0_RST);
    //==================================================
    // Init Module Clock - PWM1
    //==================================================
    CLK_SetModuleClock(PWM1_MODULE, CLK_CLKSEL3_PWM1_S_PLL, 0);
    CLK_EnableModuleClock(PWM1_MODULE);
    SYS_ResetModule(PWM1_RST);
    //==================================================
    // Init Module Clock - UART1
    //==================================================
    CLK_SetModuleClock(UART1_MODULE, CLK_CLKSEL1_UART_S_HXT, CLK_CLKDIV_UART(1));
    CLK_EnableModuleClock(UART1_MODULE);
    SYS_ResetModule(UART1_RST);
    //==================================================
    // Init Module Clock - CAN0
    //==================================================
    CLK_EnableModuleClock(CAN0_MODULE);
    SYS_ResetModule(CAN0_RST);


    //================================================================================
    // Init Multi Function Pin
    //================================================================================

    //==================================================
    // Init Multi Function Pin - Shooter 	- Motor_01_PWM	PA13/PWM0_CH1
    //==================================================
    SYS->GPA_MFP  &= ~(SYS_GPA_MFP_PA13_Msk);
    SYS->GPA_MFP  |=   SYS_GPA_MFP_PA13_PWM0_CH1;
    SYS->ALT_MFP4 &= ~(SYS_ALT_MFP4_PA13_Msk);
    SYS->ALT_MFP4 |=   SYS_ALT_MFP4_PA13_PWM0_CH1;
    //==================================================
    // Init Multi Function Pin - Platform 	- Motor_02_IN1	PA12/PWM0_CH0
    //==================================================
    SYS->GPA_MFP  &= ~(SYS_GPA_MFP_PA12_Msk);
    SYS->GPA_MFP  |=   SYS_GPA_MFP_PA12_PWM0_CH0;
    SYS->ALT_MFP4 &= ~(SYS_ALT_MFP4_PA12_Msk);
    SYS->ALT_MFP4 |=   SYS_ALT_MFP4_PA12_PWM0_CH0;
    //==================================================
    // Init Multi Function Pin - Feeder 	- Motor_03_IN3	PA2 /PWM1_CH0
    //==================================================
    SYS->GPA_MFP  &= ~(SYS_GPA_MFP_PA2_Msk);
    SYS->GPA_MFP  |=   SYS_GPA_MFP_PA2_PWM1_CH0;
    SYS->ALT_MFP3 &= ~(SYS_ALT_MFP3_PA2_Msk);
    SYS->ALT_MFP3 |=   SYS_ALT_MFP3_PA2_PWM1_CH0;
    //==================================================
    // Init Multi Function Pin - UART1
    //==================================================
    SYS->GPB_MFP  &= ~(SYS_GPB_MFP_PB4_Msk       | SYS_GPB_MFP_PB5_Msk);
    SYS->GPB_MFP  |=   SYS_GPB_MFP_PB4_UART1_RXD | SYS_GPB_MFP_PB5_UART1_TXD;
    //==================================================
    // Init Multi Function Pin - CAN0
    //==================================================
    SYS->GPD_MFP  &= ~(SYS_GPD_MFP_PD6_Msk       | SYS_GPD_MFP_PD7_Msk);
    SYS->GPD_MFP  =    SYS_GPD_MFP_PD6_CAN0_RXD  | SYS_GPD_MFP_PD7_CAN0_TXD;
}

void f_SYS_Exit(void)
{
	PWM_Stop(PWM0, PWM_CH_0_MASK); // Shooter  - Motor_01 - PA13/PWM0_CH1
	PWM_Stop(PWM0, PWM_CH_0_MASK); // Platform - Motor_02 - PA12/PWM0_CH0
	PWM_Stop(PWM1, PWM_CH_0_MASK); // Feeder   - Motor_03 - PA2 /PWM1_CH0
	UART_Close(UART1);
	CAN_Close(CAN0);
}

void f_Startup_Init(void)
{
	//==================================================
	// I/O Configuration
	//==================================================

	GPIO_SetMode(PC, BIT0, GPIO_PMD_OUTPUT); 	// LED_8
	GPIO_SetMode(PC, BIT1, GPIO_PMD_OUTPUT); 	// LED_7
	GPIO_SetMode(PC, BIT2, GPIO_PMD_OUTPUT); 	// LED_6
	GPIO_SetMode(PC, BIT3, GPIO_PMD_OUTPUT); 	// LED_5
	PC0 = 1;
	PC1 = 1;
	PC2 = 1;
	PC3 = 1;

	// LED_Operation
	GPIO_SetMode(PB, BIT0, GPIO_PMD_OUTPUT); 	// LED_Operation 	// Down
	GPIO_SetMode(PB, BIT1, GPIO_PMD_OUTPUT); 	// LED_Operation 	// Up
	PB0 = 1;
	PB1 = 1;

	// Shooter 	// Motor_01_PWM		PA13/PWM0_CH1
	GPIO_SetMode(PA, BIT14,	GPIO_PMD_OUTPUT); 	// Shooter 	// Motor_01_Direction	PA14/PWM0_CH2
	GPIO_SetMode(PA, BIT15, GPIO_PMD_OUTPUT); 	// Shooter 	// Motor_01_Enable		PA15/PWM0_CH3

	// Platform	// Motor_02_IN1		PA12/PWM0_CH0
	GPIO_SetMode(PA, BIT1,  GPIO_PMD_OUTPUT); 	// Platform	// Motor_02_IN2 		PA1 /PWM0_CH5
	GPIO_SetMode(PA, BIT4,  GPIO_PMD_OUTPUT); 	// Platform	// Motor_02_Enable		PA4
	GPIO_SetMode(PC, BIT7, 	GPIO_PMD_INPUT); 	// Motor_02_Limit_Up	PC7
	GPIO_SetMode(PC, BIT6, 	GPIO_PMD_INPUT);	// Motor_02_Limit_Down	PC6

	// Feeder 	// Motor_03_IN3		PA2 /PWM1_CH0
	GPIO_SetMode(PA, BIT3,  GPIO_PMD_OUTPUT); 	// Feeder	// Motor_03_IN4			PA3 /PWM1_CH1
	GPIO_SetMode(PA, BIT5,  GPIO_PMD_OUTPUT); 	// Feeder	// Motor_03_Enable		PA5
	GPIO_SetMode(PB, BIT8, 	GPIO_PMD_INPUT); 	// Motor_03_Limit_In	PB8
	GPIO_SetMode(PF, BIT8, 	GPIO_PMD_INPUT);	// Motor_03_Litmit_Out	PF8

	if((PC6==0)&&(PC7==1))
	{
		PC0 = 0;
		PC1 = 1;
	    g_Motor_02_Position_Status_Platform = 1;
	}
	else if((PC6==1)&&(PC7==1))
	{
		PC0 = 1;
	    PC1 = 1;
	    g_Motor_02_Position_Status_Platform = 2;
	}
	else if((PC6==1)&&(PC7==0))
	{
		PC0 = 1;
		PC1 = 0;
	    g_Motor_02_Position_Status_Platform = 3;
	}

	// Shooter
	f_Robot_Top_Shooter(0,0);
	// Platform
	f_Robot_Top_Platform(0,0);
	// Feeder
	f_Robot_Top_Feeder(0,0);

	// CAN Standby 	PD14 //0=Normal, 1=Standby
	GPIO_SetMode(PF, BIT5,  GPIO_PMD_OUTPUT); 	// CAN Standby
	PF5 = 0;

	// Init (UART1) // BT
	UART_Open(UART1, 9600);
	UART_EnableInt(UART1, (UART_IER_RDA_IEN_Msk));
	NVIC_EnableIRQ(UART1_IRQn);

	// Init (CAN)
	//CAN_Open(CAN0, 500000, CAN_NORMAL_MODE);
	//CAN_EnableInt(CAN0, CAN_CON_IE_Msk | CAN_CON_SIE_Msk);
	//NVIC_SetPriority(CAN0_IRQn, (1 << __NVIC_PRIO_BITS) - 2);
	//NVIC_EnableIRQ(CAN0_IRQn);
	//CAN_SetRxMsg(CAN0, 2, CAN_STD_ID, m_Device_ID_Master);
}

int main(void)
{
	unsigned int t_Count_01 = 0;
	unsigned int DoSomething = 0;


	SYS_UnlockReg();
	f_SYS_Init();
	SYS_LockReg();

	f_Startup_Init();

	g_User_Action_CMD_00 = 's';

    while(1)
    {
    	if((PC6==1)&&(PC7==0))
    	{
    		PC0 = 1;
    		PC1 = !PC1;

    		if(g_Motor_02_Position_Status_Platform!=11)
    		{
    			g_Motor_02_Position_Status_Platform = 1; // Up - Top Limit

    			if(g_Motor_02_Position_Status_Platform==1)
    			{
    				g_Motor_02_Position_Status_Platform=11;
    				g_User_Action_CMD_00='s';
    			}
    		}
    	}
    	else if((PC6==1)&&(PC7==1))
    	{
    		PC0 = !PC0;
    		PC1 = !PC1;
    		g_Motor_02_Position_Status_Platform = 2; // Middle Range
    	}
    	else if((PC6==0)&&(PC7==1))
    	{
    		PC0 = !PC0;
    		PC1 = 1;

    		if(g_Motor_02_Position_Status_Platform!=33)
    		{
    			g_Motor_02_Position_Status_Platform = 3; // Down - Bottom Limit

    			if(g_Motor_02_Position_Status_Platform==3)
    			{
    				g_Motor_02_Position_Status_Platform=33;
    			    g_User_Action_CMD_00='s';
    			}
    		}
    	}


    	if(g_User_Action_CMD_00 == 's') // stop
    	{
    		g_User_Action_CMD_00  = 'z';
    		// Shooter
    		f_Robot_Top_Shooter(0,0);
    		// Platform
    		f_Robot_Top_Platform(0,0);
    	}
    	else if (g_User_Action_CMD_00 == 'f') // up
    	{
    		g_User_Action_CMD_00  = 'z';
    		// Platform
    		//if(PC7!=0)
    		if(g_Motor_02_Position_Status_Platform!=11)
    		{
    			f_Robot_Top_Platform(1,80);
    		}
    	}
    	else if (g_User_Action_CMD_00 == 'b') // down
    	{
    		g_User_Action_CMD_00  = 'z';
    		// Platform
    		//if(PC6!=0)
    		if(g_Motor_02_Position_Status_Platform!=33)
    		{
    			f_Robot_Top_Platform(2,60);
    		}
    	}
    	else if (g_User_Action_CMD_00 == 'r') // forward right
    	{
    		g_User_Action_CMD_00  = 'z';
    		// Feeder
    	}
    	else if (g_User_Action_CMD_00 == 'l') // forward left
    	{
    		g_User_Action_CMD_00  = 'z';
    		// Feeder
    	}
    	else if (g_User_Action_CMD_00 == 'u') // center rotate
    	{
    		g_User_Action_CMD_00  = 'z';
    		f_Robot_Top_Shooter(1, 50);
    	}
    	else if (g_User_Action_CMD_00 == 'c') // center rotate
    	{
    		g_User_Action_CMD_00  = 'z';
    		f_Robot_Top_Shooter(1, 40);
    	}
    	else if (g_User_Action_CMD_00 == 'd') // center rotate
    	{
    		g_User_Action_CMD_00  = 'z';
    		f_Robot_Top_Shooter(1, 30);
    	}



    	for(t_Count_01=0;t_Count_01<100000;t_Count_01++)
    	{
    		DoSomething = 999;
    	}
    }

    f_SYS_Exit();

    return 0;
}
